diff --git a/arch/x86/kvm/Makefile b/arch/x86/kvm/Makefile
index f9dddb8cb466..a4c0e75c990e 100644
--- a/arch/x86/kvm/Makefile
+++ b/arch/x86/kvm/Makefile
@@ -8,7 +8,7 @@ include $(srctree)/virt/kvm/Makefile.kvm
 kvm-y			+= x86.o emulate.o i8259.o irq.o lapic.o \
 			   i8254.o ioapic.o irq_comm.o cpuid.o pmu.o mtrr.o \
 			   debugfs.o mmu/mmu.o mmu/page_track.o \
-			   mmu/spte.o
+			   mmu/spte.o kvm_tracer_hooks.o
 
 kvm-$(CONFIG_X86_64) += mmu/tdp_iter.o mmu/tdp_mmu.o
 kvm-$(CONFIG_KVM_HYPERV) += hyperv.o
diff --git a/arch/x86/kvm/kvm_tracer_hooks.c b/arch/x86/kvm/kvm_tracer_hooks.c
new file mode 100644
index 000000000000..c7b2d1217b55
--- /dev/null
+++ b/arch/x86/kvm/kvm_tracer_hooks.c
@@ -0,0 +1,66 @@
+#include <linux/kvm_host.h>
+#include "vmx/vmx.h"
+
+static int kvm_tracer_handle_debug_exception_stub(struct kvm_vcpu *vcpu, u32 intr_info, u64 dr6)
+{
+	return 1;
+}
+
+static int kvm_tracer_vm_create_stub(struct kvm *kvm)
+{
+	return 0;
+}
+
+static void kvm_tracer_vm_destroy_stub(struct kvm *kvm)
+{
+	/* Stub implementation - does nothing */
+}
+
+static int kvm_tracer_vcpu_create_stub(struct kvm_vcpu *vcpu)
+{
+	return 0;
+}
+
+static void kvm_tracer_vcpu_destroy_stub(struct kvm_vcpu *vcpu)
+{
+	/* Stub implementation - does nothing */
+}
+
+int (*kvm_tracer_handle_debug_exception_fn)(struct kvm_vcpu *vcpu, u32 intr_info, u64 dr6) = kvm_tracer_handle_debug_exception_stub;
+int (*kvm_tracer_vm_create_fn)(struct kvm *kvm) = kvm_tracer_vm_create_stub;
+void (*kvm_tracer_vm_destroy_fn)(struct kvm *kvm) = kvm_tracer_vm_destroy_stub;
+int (*kvm_tracer_vcpu_create_fn)(struct kvm_vcpu *vcpu) = kvm_tracer_vcpu_create_stub;
+void (*kvm_tracer_vcpu_destroy_fn)(struct kvm_vcpu *vcpu) = kvm_tracer_vcpu_destroy_stub;
+
+int kvm_tracer_register_functions(int (*debug_exception_fn)(struct kvm_vcpu *, u32, u64),
+                                 int (*vm_create_fn)(struct kvm *),
+                                 void (*vm_destroy_fn)(struct kvm *),
+                                 int (*vcpu_create_fn)(struct kvm_vcpu *),
+                                 void (*vcpu_destroy_fn)(struct kvm_vcpu *))
+{
+	kvm_tracer_handle_debug_exception_fn = debug_exception_fn;
+	kvm_tracer_vm_create_fn = vm_create_fn;
+	kvm_tracer_vm_destroy_fn = vm_destroy_fn;
+	kvm_tracer_vcpu_create_fn = vcpu_create_fn;
+	kvm_tracer_vcpu_destroy_fn = vcpu_destroy_fn;
+	
+	return 0;
+}
+
+void kvm_tracer_unregister_functions(void)
+{
+	kvm_tracer_handle_debug_exception_fn = kvm_tracer_handle_debug_exception_stub;
+	kvm_tracer_vm_create_fn = kvm_tracer_vm_create_stub;
+	kvm_tracer_vm_destroy_fn = kvm_tracer_vm_destroy_stub;
+	kvm_tracer_vcpu_create_fn = kvm_tracer_vcpu_create_stub;
+	kvm_tracer_vcpu_destroy_fn = kvm_tracer_vcpu_destroy_stub;
+}
+
+EXPORT_SYMBOL_GPL(kvm_tracer_handle_debug_exception_fn);
+EXPORT_SYMBOL_GPL(kvm_tracer_vm_create_fn);
+EXPORT_SYMBOL_GPL(kvm_tracer_vm_destroy_fn);
+EXPORT_SYMBOL_GPL(kvm_tracer_vcpu_create_fn);
+EXPORT_SYMBOL_GPL(kvm_tracer_vcpu_destroy_fn);
+
+EXPORT_SYMBOL_GPL(kvm_tracer_register_functions);
+EXPORT_SYMBOL_GPL(kvm_tracer_unregister_functions);
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index eec0aa13e002..c3af5962b55a 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -135,6 +135,7 @@ module_param(dump_invalid_vmcs, bool, 0644);
 #define MSR_BITMAP_MODE_X2APIC		1
 #define MSR_BITMAP_MODE_X2APIC_APICV	2
 
+
 #define KVM_VMX_TSC_MULTIPLIER_MAX     0xffffffffffffffffULL
 
 /* Guest_tsc -> host_tsc conversion requires 64-bit division.  */
@@ -5337,6 +5338,12 @@ static int handle_exception_nmi(struct kvm_vcpu *vcpu)
 	switch (ex_no) {
 	case DB_VECTOR:
 		dr6 = vmx_get_exit_qual(vcpu);
+
+        if (kvm_tracer_handle_debug_exception_fn(vcpu, intr_info, dr6) == 0) {
+            // Tracer handled it, don't process further
+            return 1;
+        }
+		
 		if (!(vcpu->guest_debug &
 		      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {
 			/*
@@ -7577,6 +7584,7 @@ int vmx_vcpu_create(struct kvm_vcpu *vcpu)
 
 	BUILD_BUG_ON(offsetof(struct vcpu_vmx, vcpu) != 0);
 	vmx = to_vmx(vcpu);
+    memset(&vmx->tracer_state, 0, sizeof(vmx->tracer_state));
 
 	INIT_LIST_HEAD(&vmx->pi_wakeup_list);
 
@@ -8767,4 +8775,28 @@ static int __init vmx_init(void)
 	kvm_x86_vendor_exit();
 	return r;
 }
+
+/*
+ * Export VMCS access functions for kvm_tracer module
+ * Note: vmcs_readl and vmcs_writel are static inline, so we need wrapper functions
+ */
+unsigned long kvm_tracer_vmcs_readl(unsigned long field)
+{
+	return vmcs_readl(field);
+}
+
+void kvm_tracer_vmcs_writel(unsigned long field, unsigned long value)
+{
+	vmcs_writel(field, value);
+}
+
+EXPORT_SYMBOL_GPL(kvm_tracer_vmcs_readl);
+EXPORT_SYMBOL_GPL(kvm_tracer_vmcs_writel);
+EXPORT_SYMBOL_GPL(current_vmcs);
+EXPORT_SYMBOL_GPL(vmcs_field_to_evmcs_1);
+EXPORT_SYMBOL_GPL(nr_evmcs_1_fields);
+EXPORT_SYMBOL_GPL(vmwrite_error);
+EXPORT_SYMBOL_GPL(vmread_error);
+EXPORT_SYMBOL_GPL(__kvm_is_using_evmcs);
+
 module_init(vmx_init);
diff --git a/arch/x86/kvm/vmx/vmx.h b/arch/x86/kvm/vmx/vmx.h
index 951e44dc9d0e..93836237b40e 100644
--- a/arch/x86/kvm/vmx/vmx.h
+++ b/arch/x86/kvm/vmx/vmx.h
@@ -27,6 +27,13 @@
 
 #define MAX_NR_LOADSTORE_MSRS	8
 
+struct kvm_tracer_state {
+    bool tracer_enabled;
+    u64 breakpoint_addresses[4];
+    u64 breakpoint_types[4];
+    bool breakpoints_active;
+};
+
 struct vmx_msrs {
 	unsigned int		nr;
 	struct vmx_msr_entry	val[MAX_NR_LOADSTORE_MSRS];
@@ -248,6 +255,7 @@ struct nested_vmx {
 
 struct vcpu_vmx {
 	struct kvm_vcpu       vcpu;
+	struct kvm_tracer_state tracer_state;
 	u8                    fail;
 	u8		      x2apic_msr_bitmap_mode;
 
@@ -758,4 +766,22 @@ static inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)
 	vmx->segment_cache.bitmask = 0;
 }
 
+/*
+ * KVM Tracer Function Pointer Declarations
+ * These are shared across all KVM modules
+ */
+extern int (*kvm_tracer_handle_debug_exception_fn)(struct kvm_vcpu *vcpu, u32 intr_info, u64 dr6);
+extern int (*kvm_tracer_vm_create_fn)(struct kvm *kvm);
+extern void (*kvm_tracer_vm_destroy_fn)(struct kvm *kvm);
+extern int (*kvm_tracer_vcpu_create_fn)(struct kvm_vcpu *vcpu);
+extern void (*kvm_tracer_vcpu_destroy_fn)(struct kvm_vcpu *vcpu);
+
+/* Registration functions */
+extern int kvm_tracer_register_functions(int (*debug_exception_fn)(struct kvm_vcpu *, u32, u64),
+                                        int (*vm_create_fn)(struct kvm *),
+                                        void (*vm_destroy_fn)(struct kvm *),
+                                        int (*vcpu_create_fn)(struct kvm_vcpu *),
+                                        void (*vcpu_destroy_fn)(struct kvm_vcpu *));
+extern void kvm_tracer_unregister_functions(void);
+
 #endif /* __KVM_X86_VMX_H */
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index be7bb6d20129..458c4fadeb8c 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -33,6 +33,7 @@
 #include "lapic.h"
 #include "xen.h"
 #include "smm.h"
+#include "vmx/vmx.h"
 
 #include <linux/clocksource.h>
 #include <linux/interrupt.h>
@@ -227,6 +228,7 @@ EXPORT_SYMBOL_GPL(allow_smaller_maxphyaddr);
 bool __read_mostly enable_apicv = true;
 EXPORT_SYMBOL_GPL(enable_apicv);
 
+
 const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
 	KVM_GENERIC_VM_STATS(),
 	STATS_DESC_COUNTER(VM, mmu_shadow_zapped),
@@ -12340,6 +12342,8 @@ int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
 	if (r)
 		goto free_guest_fpu;
 
+
+	kvm_tracer_vcpu_create_fn(vcpu);
 	kvm_xen_init_vcpu(vcpu);
 	vcpu_load(vcpu);
 	kvm_vcpu_after_set_cpuid(vcpu);
@@ -12404,6 +12408,7 @@ void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
 	kvm_xen_destroy_vcpu(vcpu);
 	kvm_hv_vcpu_uninit(vcpu);
 	kvm_pmu_destroy(vcpu);
+	kvm_tracer_vcpu_destroy_fn(vcpu);
 	kfree(vcpu->arch.mce_banks);
 	kfree(vcpu->arch.mci_ctl2_banks);
 	kvm_free_lapic(vcpu);
@@ -14010,6 +14015,18 @@ int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size,
 }
 EXPORT_SYMBOL_GPL(kvm_sev_es_string_io);
 
+void kvm_tracer_get_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
+{
+    kvm_arch_vcpu_ioctl_get_regs(vcpu, regs);
+}
+EXPORT_SYMBOL_GPL(kvm_tracer_get_regs);
+
+void kvm_tracer_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
+{
+    kvm_arch_vcpu_ioctl_set_regs(vcpu, regs);
+}
+EXPORT_SYMBOL_GPL(kvm_tracer_set_regs);
+
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_entry);
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_exit);
 EXPORT_TRACEPOINT_SYMBOL_GPL(kvm_fast_mmio);
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index d0ce45c7b5cd..9802de2d160f 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -58,6 +58,7 @@
 #include "async_pf.h"
 #include "kvm_mm.h"
 #include "vfio.h"
+#include "../arch/x86/kvm/vmx/vmx.h"
 
 #include <trace/events/ipi.h>
 
@@ -94,6 +95,7 @@ unsigned int halt_poll_ns_shrink = 2;
 module_param(halt_poll_ns_shrink, uint, 0644);
 EXPORT_SYMBOL_GPL(halt_poll_ns_shrink);
 
+
 /*
  * Allow direct access (from KVM or the CPU) without MMU notifier protection
  * to unpinned pages.
@@ -1156,6 +1158,8 @@ static struct kvm *kvm_create_vm(unsigned long type, const char *fdname)
 	if (r)
 		goto out_err_no_irq_routing;
 
+	kvm_tracer_vm_create_fn(kvm);
+		
 	refcount_set(&kvm->users_count, 1);
 
 	for (i = 0; i < kvm_arch_nr_memslot_as_ids(kvm); i++) {
@@ -1275,6 +1279,7 @@ static void kvm_destroy_vm(struct kvm *kvm)
 	list_del(&kvm->vm_list);
 	mutex_unlock(&kvm_lock);
 	kvm_arch_pre_destroy_vm(kvm);
+	kvm_tracer_vm_destroy_fn(kvm);
 
 	kvm_free_irq_routing(kvm);
 	for (i = 0; i < KVM_NR_BUSES; i++) {
@@ -6479,4 +6484,6 @@ void kvm_exit(void)
 	kvm_async_pf_deinit();
 	kvm_irqfd_exit();
 }
+
+
 EXPORT_SYMBOL_GPL(kvm_exit);
